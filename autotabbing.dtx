% \iffalse meta-comment
%
% Copyright (C) 2015 by Pascal Germroth <pascal@germroth.name>
% ------------------------------------------------------------
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.2
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
%    http://www.latex-project.org/lppl.txt
%
% and version 1.2 or later is part of all distributions of LaTeX 
% version 1999/12/01 or later.
%
% \fi
%
%<*driver>
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX

\input docstrip.tex
\keepsilent
\askforoverwritefalse

\usedir{tex/luatex/autotabbing}

\let\MetaPrefix\relax
\preamble

This is a generated file.

Copyright (C) 2015 by Pascal Germroth <pascal@germroth.name>

This file may be distributed and/or modified under the conditions of
the LaTeX Project Public License, either version 1.2 of this license
or (at your option) any later version.  The latest version of this
license is in:

   http://www.latex-project.org/lppl.txt

and version 1.2 or later is part of all distributions of LaTeX version
1999/12/01 or later.

\endpreamble

\let\MetaPrefix\DoubleperCent
\generate{\file{autotabbing.sty}{\from{autotabbing.dtx}{package}}}

\def\MetaPrefix{-- }
\edef\luapostamble{%
  \MetaPrefix^^J%
  \MetaPrefix\space End of File `\outFileName'.%
}
\usepostamble\luapostamble
\generate{\file{autotabbing.lua}{\from{autotabbing.dtx}{lua}}}

\expandafter\endbatchfile
\fi
%</driver>
%
% \iffalse
%<*driver>
\ProvidesFile{autotabbing.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{autotabbing}
%<*package>
    [2015/03/16 v1.0 automatic tabbing-like environment]
%</package>
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{autotabbing}
\usepackage{xcolor}
\usepackage{showexpl}
\usepackage{mathtools}
%\usepackage{lua-visual-debug}
\EnableCrossrefs
\CodelineIndex
\RecordChanges

\newcommand{\DescribeKey}{\DescribeEnv}
\newenvironment{luafun}[1]{%
  \begin{environment}{#1()}%
}{%
  \end{environment}%
}

\parindent=0pt

\begin{document}
\changes{v1.0}{2015/03/16}{Initial version}

\GetFileInfo{autotabbing.dtx}

\DoNotIndex{\newcommand,\newenvironment}

\title{The \textsf{autotabbing} package\thanks{This document
  corresponds to \textsf{autotabbing}~\fileversion, dated \filedate.}}
\author{Pascal Germroth \\ \texttt{pascal@germroth.name}}

\maketitle

\section{Introduction}

This package attempts to combine the way tabstops can be defined inline from
|tabbing| with the way column sizes are determined automatically from |tabular|.
You don't define columns beforehand but simply insert named tabstops which will
be aligned with each other, as determined by the content.

Originally written to pretty print aligned Haskell code in a proportional font,
see the \textsf{autoverbalign} package for an attempt to guess these tabstops from
monospace-aligned text.
Declaring a complex alignment like this is easier
than using a |tabbing| environment or a |tabular|.
\begin{autotabbing}
  map :: &[1](a $\rightarrow$ b) $\rightarrow$ &[2] [Maybe a]
  &[3] $\rightarrow$ [b] \quad-\/- this is a longer comment\\
  map &[1] fun &[2] (x:xs) &[3]= case x of &[4] Just y  & $\rightarrow$ fun y : map xs\\
  \{-\hfill centered comment \hfill-\} &[4] Nothing & $\rightarrow$ map xs\\
  map &[1] \_ &[2] [] &[3] = []
\end{autotabbing}

Here is a flexible three-column layout---there is no need to define the columns
beforehand or use |\multicolumn| for cell spans.
\begin{LTXexample}
\begin{autotabbing}
  first & second & third \\
  \hfill this is centered \hfill
    &[2] \hfill third \\
  something longer & \dotfill \\
  this takes \dotfill the whole row \\
  & multiple columns
\end{autotabbing}
\end{LTXexample}

\vfil

There are no high-level functions at the moment, i.e. aligning content is done
using |\hfill|, there are no borders or backgrounds or cell templates.
There is also no support for cells spanning multiple rows.
\begin{autotabbing}
  The & environment supports & breaking across & pages \\
  while & content & says & aligned
\end{autotabbing}
Of course for simple layouts \textsf{longtable} would be more flexible here,
but this package doesn't try to provide full-featured tables but instead a
very simple automatic alignment function.

\section{Usage}

Load the package using
|\usepackage|\oarg{kvargs}|{autotabbing}|.

Use the environment:
|\begin{autotabbing}|\oarg{kvargs} ... |\end{autotabbing}|.

Use the optional arguments or |\autotabbingsetup|\marg{kvargs} to set options.

\DescribeMacro{&}
Set a tabstop using |&|\oarg{id}. This introduces a new cell.
Stop numbers must be given in ascending order within each row, but arbitrary
gaps are fine.
If no \meta{id} is given or a smaller one, it will just use the next available.

{\autotabbingsetup{draft}
\begin{LTXexample}
\begin{autotabbing}
  foo & bar & baz &[20] qux & zzy
\end{autotabbing}
\end{LTXexample}

|&| ignores the following spaces but not the preceding ones.
To get a space at the start of a cell, hide it:
\begin{LTXexample}
\begin{autotabbing}
  before & none& { after}
\end{autotabbing}
\end{LTXexample}

All tabs with the same ID are aligned to the same position; but so may multiple
independent tabs (2 and 3 below). While tabs must be used in ascending order,
a tab with a lower ID may still end up to the right of one with a
higher ID (4 and 5 below). This is intentional and allows for extremely
complex layouts.
\begin{LTXexample}
\begin{autotabbing}
  a     & xxx & c      &[5] nnn \\
  aaa   & x   &[3] ccc &[5] n \\
  aaaaa & xxx &[3] cccccc &[4] n
\end{autotabbing}
\end{LTXexample}
}


\DescribeMacro{\\}
Start a new row using |\\|\oarg{length}.
Don't end the last one with |\\|, it will cause an empty row.
The optional argument may contain a length passed to |\vspace|.

\begin{LTXexample}
\begin{autotabbing}
  a line\\
  some more space\\[.5em]
  empty line after\\
\end{autotabbing}
\end{LTXexample}

\DescribeMacro{\intertext}
Like in \textsf{amsmath}, |\intertext|\marg{content} allows interrupting
an alignment, aligning across the break.
Unlike in the math environments, there should \emph{not} be a |\\| before the
|\intertext| as this will cause an empty line.
The content may contain paragraph- and page breaks, it will be added directly
to the parent vlist.
\begin{LTXexample}
\begin{autotabbing}
  some cells: & here & being
  \intertext{
  interrupted with

  multiple paragraphs of text
  }
  and & continuing & aligned
\end{autotabbing}
\end{LTXexample}

\subsection{Spacing}
\DescribeKey{aboveskip}
\DescribeKey{belowskip}
\DescribeKey{aboveintertextskip}
\DescribeKey{belowintertextskip}
\DescribeKey{belowskip}
\DescribeKey{colsep}
Similar to \textsf{tabbing}, the row boxes are laid out like paragraph lines.
There are options provided for additional vertical spacing, defaulting to
|.5\baselineskip|:
For each new row |\\|\oarg{additional} extra space can be inserted.
|aboveskip| and |belowskip| are inserted before and after
the first and last row respectively.
|aboveintertextskip| and |belowintertextskip| are inserted before and after
an |\intertext|, adjust this instead of using |\\| here.
To spread the layout there are |colsep| and |rowsep|, which default to zero.

\begingroup
  \renewcommand{\hspace}[1]{%
    \hbox{$\xleftrightarrow{\text{\scriptsize\ttfamily #1}}$}}
  \renewcommand{\vspace}[1]{%
    \hbox{$\updownarrow$\scriptsize\ttfamily #1}}
  \begin{autotabbing}[final,
    aboveskip=aboveskip,
    belowskip=belowskip,
    aboveintertextskip=aboveintertextskip,
    belowintertextskip=belowintertextskip,
    rowsep=rowsep,
    colsep=colsep
  ]
    cell & cell \\[additional]
    cell & cell
    \intertext{intertext}
    cell & cell
  \end{autotabbing}
\endgroup

Alignment takes |colsep| into account even when spanning multiple columns:
\begin{LTXexample}
\begin{autotabbing}[colsep=5mm]
  xxxxxxxx& xxxxxxxx& xxxxxxxx\\
  (\dotfill)& (\dotfill)
\end{autotabbing}
\end{LTXexample}

\subsection{Debugging}
\DescribeKey{draft}
\DescribeKey{final}
The |draft| option, and its opposite |final| can be used to respectively
enable or disable a debug mode where tabs are drawn as zero-sized
(i.e. with no impact on the layout) markers showing the tab's ID.

\begin{LTXexample}
\begin{autotabbing}[draft]
  x & x &[3] x & x \\
  x & x &[4] x & x
\end{autotabbing}
\end{LTXexample}


\DocInput{autotabbing.dtx}
\PrintChanges
\PrintIndex
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \StopEventually{}
% \section{Implementation}
%
% Load the Lua portion of the package
%    \begin{macrocode}
%<*package>
\RequirePackage{luatexbase}
\RequireLuaModule{autotabbing}
%    \end{macrocode}
% Define the options
%    \begin{macrocode}
\RequirePackage{kvoptions}
\SetupKeyvalOptions{family=autotabbing, prefix=autotabbing@}

\DeclareBoolOption{draft}
\DeclareComplementaryOption{final}{draft}

\DeclareStringOption[.5\baselineskip]{aboveskip}
\DeclareStringOption[.5\baselineskip]{belowskip}

\DeclareStringOption[.5\baselineskip]{aboveintertextskip}
\DeclareStringOption[.5\baselineskip]{belowintertextskip}

\DeclareStringOption[0pt]{colsep}
\DeclareStringOption[0pt]{rowsep}

\ProcessKeyvalOptions{autotabbing}
%    \end{macrocode}
%
% \begin{macro}{\autotabbingsetup}
% Macro to set the options
%    \begin{macrocode}
\newcommand*{\autotabbingsetup}{\setkeys{autotabbing}}
%    \end{macrocode}
% \end{macro}
%
% We use a counter to keep track of the current tabstop.
%    \begin{macrocode}
\newcounter{autotabbing@current}
%    \end{macrocode}
%
% \begin{macro}{\autotabbing@cell@start}
% Draft visualisation: show the tabstops and numbers.
%    \begin{macrocode}
\newcommand{\autotabbing@cell@start}{%
  \ifautotabbing@draft%
    \ifnum\value{autotabbing@current} > 0%
      \raisebox{0pt}[0pt][0pt]{% zero height box
        \ifdefined\color\color{red}\fi%
        \makebox[0pt][c]{% zero width rule
          \rule[-.1\baselineskip]{.5pt}{.5\baselineskip}}%
        \makebox[0pt][c]{% zero width label
          \raisebox{0.5\baselineskip}{%
            \fontsize{6pt}{6pt}\sffamily%
            \theautotabbing@current%
          }%
        }%
      }%
    \fi%
  \fi%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{autotabbing@cell}
% We put the cell's contents into a box,
% giving it a tag and the ID of the starting tab via attributes.
% (Just using 0 and 1 should be fine here since the box will be recreated
% without attributes once its size is known)
%
% The tabular-like syntax is only available inside cells, not i.e |\intertext|.
%
% We ignore the spaces at the beginning to avoid inconsistency with the optional
% argument of |&| and ease, but allow them at the end where it's easy to choose.
% The box ends with a glue so the content won't stretch when the width is ajusted,
% manual alignment using |\hfill| still works.
%    \begin{macrocode}
\catcode`&=\active
\newenvironment*{autotabbing@cell}{%
  \hbox
    attr0=2% mark as cell
    attr1=\value{autotabbing@current}
  \bgroup%
    % syntax
    \let\\=\autotabbing@row@next%
    \let&=\autotabbing@cell@next%
    \catcode`\&=\active%
    \let\intertext=\autotabbing@intertext%
    % start hook
    \autotabbing@cell@start%
    \ignorespaces%
}{%
    \hss%
  \egroup%
}
\catcode`&=4

%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\autotabbing@cell@next}
% Available as |&| in the environment.
% To ensure increasing tabs, without or with an invalid argument
% just advance the counter.
%    \begin{macrocode}
\newcommand*{\autotabbing@cell@next}[1][0]{%
  \end{autotabbing@cell}%
  \ifnum #1 > \value{autotabbing@current}%
    \setcounter{autotabbing@current}{#1}%
  \else%
    \stepcounter{autotabbing@current}%
  \fi%
  \hspace{\autotabbing@colsep}%
  \begin{autotabbing@cell}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{\autotabbing@row}
% A row starts at tab 0. Mark the row box using attribute.
% (Should be fine to use |attr0| here as well, the box will be recreated)
%    \begin{macrocode}
\newenvironment*{autotabbing@row}{%
  \setcounter{autotabbing@current}{0}%
  \hbox attr0=1 % mark as row
  \bgroup%
    \begin{autotabbing@cell}%
}{%
    \end{autotabbing@cell}%
  \egroup%
}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\autotabbing@row@next}
% Available as |\\| in the environment.
% Closes the current row and immediately opens a new one.
% Insert additional space between the two row boxes.
%    \begin{macrocode}
\newcommand{\autotabbing@row@next}[1][0pt]{%
  \end{autotabbing@row}%
  \vspace{\autotabbing@rowsep}%
  \vspace{#1}%
  \begin{autotabbing@row}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\autotabbing@intertext}
% Interrupt the display. Doesn't check if the last row may have been empty.
%    \begin{macrocode}
\newcommand{\autotabbing@intertext}[1]{%
  \end{autotabbing@row}%
  \vspace{\autotabbing@aboveintertextskip}%
  #1%
  \par%
  \vspace{\autotabbing@belowintertextskip}%
  \begin{autotabbing@row}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{autotabbing}
% Collect the rows into a temporary vbox, use Lua to adjust the cells
% and insert the vbox's contents into the parent vbox.
% We unskip the final space here to allow a linebreak before the |\end|
% without having to use |%| in the line before.
%    \begin{macrocode}
\newenvironment*{autotabbing}[1][]{%
  \autotabbingsetup{#1}%
  % put the rows into a temporary vbox
  \par\dimen0=\prevdepth%
  \setbox0=\vbox\bgroup%
    \prevdepth=\dimen0% correct baselineskip glue
    \begin{autotabbing@row}%
      % now inside first cell
}{%
      % allow for line break before \end
      \unskip%
    \end{autotabbing@row}%
  \egroup%
  % align the cells
  \directlua{autotabbing.adjust()}%
  % output them into the parent vlist
  \vspace{\autotabbing@aboveskip}%
  \unvbox0%
  \vspace{\autotabbing@belowskip}%
  % no indent if not followed by a newline
  \noindent%
  \ignorespacesafterend%
}
%</package>
%    \end{macrocode}
% \end{environment}
%
%
%    \begin{macrocode}
%<*lua>
local err, warn, info, log =
  luatexbase.provides_module({name = 'autotabbing'})
autotabbing = autotabbing or {}

local first_tab = 0
local last_tab = 1000
%    \end{macrocode}
%
% \begin{luafun}{get\_offsets}
% Get the horizontal offsets of the tab stops.
% We measure the cells column-wise (keeping track using the |index| table,
% since we might not visit a cell in each row every step) by selecting those
% starting at the current stop (which had its offset calculated in a previous
% step), and moving the cell's end-stops.
% A cell may end at any stop with a larger index than its start.
% There may be gaps in the tab numbers, and their offsets don't have to be in
% the same order.
%    \begin{macrocode}
local function get_offsets(rows)
  local offsets = {[first_tab] = 0}
  local index = {}
  for i = 1, #rows do index[i] = 1 end
  local current = first_tab
  repeat
    for i, row in ipairs(rows) do
      local cell = row.cells[index[i]]
      if cell and cell.from == current then
        -- measure from our left edge to the left edge of the next cell
        local next_box = (row.cells[index[i] + 1] or {}).box
        local width = node.dimensions(cell.box, next_box)
        -- there may be content between cells.
        cell.right_margin = width - cell.box.width
        -- move our right tab stop accordingly
        local left = offsets[cell.from]
        local right = left + width
        if right >= (offsets[cell.to] or 0) then
          offsets[cell.to] = right
        end
        -- done with this cell
        index[i] = index[i] + 1
      end
    end
    -- find the next tab ID: it's the smallest,
    -- because tab IDs are topologically ordered.
    current = last_tab
    for i, row in ipairs(rows) do
      local cell = row.cells[index[i]]
      if cell and cell.from < current then
        current = cell.from
      end
    end
  until current == last_tab
  return offsets
end
%    \end{macrocode}
% \end{luafun}
%
% \begin{luafun}{repack\_hbox}
% Repack the box in place.
%    \begin{macrocode}
local function repack_hbox(head, old, ...)
  local new = node.hpack(old.head, ...)
  head = node.insert_before(head, old, new)
  head = node.remove(head, old)
  return head, new
end
%    \end{macrocode}
% \end{luafun}
%
% \begin{luafun}{adjust\_widths}
% Alter each cell's widths so they fit between their respective stops.
%    \begin{macrocode}
local function adjust_widths(head, rows, offsets)
  for _, row in ipairs(rows) do
    for _, cell in ipairs(row.cells) do
      -- recreate the cell at target width
      local col_width = offsets[cell.to] - offsets[cell.from]
      local width = col_width - cell.right_margin
      row.box.head, cell.box =
        repack_hbox(row.box.head, cell.box, width, 'exactly')
    end
    -- recreate the row at its new natural width
    head, row.box = repack_hbox(head, row.box)
  end
  return head
end
%    \end{macrocode}
% \end{luafun}
%
% \begin{luafun}{collect\_rows}
% Collect the cells from the current table.
%    \begin{macrocode}
local function collect_rows(table_box)
  local rows = {}
  for row_box in node.traverse(table_box.head) do
    -- skip glue, intertext, etc, without explicit row tag.
    if node.has_attribute(row_box, 0, 1) then
      local cells = {}
      for cell_box in node.traverse(row_box.head) do
        -- skip glue etc without explicit cell tag
        if node.has_attribute(cell_box, 0, 2) then
          local cell = {
            box = cell_box,
            from = node.has_attribute(cell_box, 1),
            to = last_tab
          }
          -- previous cell ends where this one starts
          local prev_cell = cells[#cells]
          if prev_cell then
            prev_cell.to = cell.from
          end
          -- cell done
          table.insert(cells, cell)
        end
      end
      -- row done
      table.insert(rows, {
        box = row_box,
        cells = cells
      })
    end
  end
  return rows
end
%    \end{macrocode}
% \end{luafun}
%
% \begin{luafun}{autotabbing.adjust}
% Entry point. Find the cells, compute tabstops and adjust the widths.
% Modifies the box in-place.
%    \begin{macrocode}
function autotabbing.adjust()
  local vbox = tex.box[0]
  local rows = collect_rows(vbox)
  local offsets = get_offsets(rows)
  vbox.head = adjust_widths(vbox.head, rows, offsets)
end
%</lua>
%    \end{macrocode}
% \end{luafun}
%
%
% \Finale
\endinput
