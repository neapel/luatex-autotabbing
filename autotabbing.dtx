% \iffalse meta-comment
%
% Copyright (C) 2015 by Pascal Germroth <pascal@germroth.name>
% ------------------------------------------------------------
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.2
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
%    http://www.latex-project.org/lppl.txt
%
% and version 1.2 or later is part of all distributions of LaTeX 
% version 1999/12/01 or later.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{autotabbing.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{autotabbing}
%<*package>
    [2015/03/16 v1.0 automatic tabbing-like environment]
%</package>
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{autotabbing}
\usepackage{color}
\usepackage{showexpl}
%\usepackage{lua-visual-debug}
\EnableCrossrefs
\CodelineIndex
\RecordChanges

\parindent=0pt

\begin{document}
\changes{v1.0}{2015/03/16}{Initial version}

\GetFileInfo{autotabbing.dtx}

\DoNotIndex{\newcommand,\newenvironment}

\title{The \textsf{autotabbing} package\thanks{This document
  corresponds to \textsf{autotabbing}~\fileversion, dated \filedate.}}
\author{Pascal Germroth \\ \texttt{pascal@germroth.name}}

\maketitle

\section{Introduction}

This package attempts to combine the way tabstops can be defined inline from
|tabbing| with the way column sizes are determined automatically from |tabular|.
You don't define columns beforehand but simply insert named tabstops which will
be aligned with each other, as determined by the content.

Originally written to pretty print aligned Haskell code in a proportional font,
see the \textsf{autoverbalign} package for an attempt to guess these tabstops from
monospace-aligned text. Declaring a complex alignment like this is easier
than using a |tabbing| environment or a |tabular|:

\medskip
\begin{autotabbing}
  map :: &[1](a $\rightarrow$ b) $\rightarrow$ &[2] [Maybe a]
  &[3] $\rightarrow$ [b] \quad-\/- this is a longer comment\\
  map &[1] fun &[2] (x:xs) &[3]= case x of &[4] Just y  & $\rightarrow$ fun y : map xs\\
  \{-\hfill centered comment \hfill-\} &[4] Nothing & $\rightarrow$ map xs\\
  map &[1] \_ &[2] [] &[3] = []
\end{autotabbing}
\medskip
Here is a flexible three-column layout:
\begin{LTXexample}
\begin{autotabbing}
  first & second & third \\
  \hfill this is centered \hfill
    &[2] \hfill third \\
  something longer & \dotfill \\
  this takes \dotfill the whole row \\
  & multiple columns
\end{autotabbing}
\end{LTXexample}

\vfil

There are no high-level functions at the moment, i.e. aligning content is done
using |\hfill|, there are no borders or backgrounds or cell templates.

The environment support breaking across pages:
\begin{autotabbing}
  here & are & some\\
  lines & of sometimes longer & text\\
  to & make & space\\
  and & show & how\\
  it & breaks & across pages\\
\end{autotabbing}
Of course for simple layouts \textsf{longtable} would be more flexible here,
but this package doesn't try to provide full-featured tables but instead a
very simple automatic alignment function.

\section{Usage}

Load the package using
|\usepackage|\oarg{kvargs}|{autotabbing}|.\\
Use the environment:
|\begin{autotabbing}|\oarg{kvargs} ... |\end{autotabbing}|.\\
Use the optional arguments or |\autotabbingsetup|\marg{kvargs} to set options.
There is only one option defined at the moment:
\begin{description}
  \item[draft] shows markers with the tabstop's numbers at their positions.
    This inherits the class option, i.e. it will be enabled when
    |\documentclass[draft]{article}| is used.
\end{description}

\DescribeMacro{&}
Set a tabstop using |&|\oarg{id}. This introduces a new cell.
Stop numbers must be given in ascending order within each row, but arbitrary
gaps are fine.
If no \meta{id} is given or a smaller one, it will just use the next available.

\autotabbingsetup{draft}
\begin{LTXexample}
\begin{autotabbing}
  foo & bar & baz &[20] qux & zzy
\end{autotabbing}
\end{LTXexample}

|&| ignores the following spaces but not the preceding ones.
To get a space at the start of a cell, hide it:
\begin{LTXexample}
\begin{autotabbing}
  before & none& { after}
\end{autotabbing}
\end{LTXexample}


\DescribeMacro{\\}
Start a new row using |\\|.
Don't end the last one with |\\|, it will cause an empty row.
There is \emph{no} optional argument to add vertical space.
TODO

\DescribeMacro{\intertext}
Like in \textsf{amsmath}, |\intertext|\marg{content} allows interrupting
an alignment, aligning across the break.
Unlike in the math environments, there should \emph{not} be a |\\| before the
|\intertext| as this will cause an empty line.
The content may contain paragraph- and page breaks, it will be added directly
to the parent vlist.
TODO There's no proper handling of spacing at the moment.
\begin{LTXexample}
  \begin{autotabbing}
  some cells: & here & being
  \intertext{
  interrupted with

  multiple paragraphs of text
  }
  and & continuing & aligned
\end{autotabbing}
\end{LTXexample}


\DescribeMacro{\abovedisplayskip}
\DescribeMacro{\baselineskip}
\DescribeMacro{\belowdisplayskip}
The environment uses the standard lengths above, between and below rows.
TODO no

% test: this should work.
\begin{autotabbing}\end{autotabbing}

\DocInput{autotabbing.dtx}
\PrintChanges
\PrintIndex
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \StopEventually{}
% \section{Implementation}
%
% Load the Lua portion of the package xx
%    \begin{macrocode}
%<*package>
\RequirePackage{luatexbase}
\RequireLuaModule{autotabbing}
%    \end{macrocode}
% Define the |draft| option
%    \begin{macrocode}
\RequirePackage{kvoptions}
\SetupKeyvalOptions{family=autotabbing, prefix=autotabbing@}
\DeclareBoolOption{draft}
\DeclareComplementaryOption{final}{draft}
\ProcessKeyvalOptions{autotabbing}
%    \end{macrocode}
%
% \begin{macro}{\autotabbingsetup}
% Macro to set the option.
%    \begin{macrocode}
\newcommand*{\autotabbingsetup}{\setkeys{autotabbing}}
%    \end{macrocode}
% \end{macro}
%
% We use a counter to keep track of the current tabstop,
% the first has index 0, the last 1000.
%    \begin{macrocode}
\newcount\autotabbing@current
%    \end{macrocode}
%
% \begin{macro}{\autotabbing@cell@start}
% Draft visualisation: show the tabstops and numbers.
%    \begin{macrocode}
\RequirePackage{color}
\newcommand{\autotabbing@cell@start}{%
  \ifautotabbing@draft%
    \ifnum\the\autotabbing@current > 0
      \raisebox{0pt}[0pt][0pt]{% zero height box
        \color{red}%
        \makebox[0pt][c]{% zero width rule
          \rule[-.1\baselineskip]{.5pt}{0.5\baselineskip}}%
        \makebox[0pt][c]{% zero width label
          \raisebox{0.5\baselineskip}% raised
            {\tiny\sffamily\the\autotabbing@current}}%
      }%
    \fi%
  \fi%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{autotabbing@cell}
% We put the cell's contents into a box and hand it to the Lua code.
% We ignore the spaces at the beginning to avoid inconsistency with the optional
% argument of |&| and ease, but allow them at the end where it's easy to choose.
% The box ends with a glue so the content won't stretch when the width is ajusted,
% manual alignment using |\hfil| still works.
%
% (Might be better to do this using attributes? Assemble the table into a big list
% of attributed cells, with optional content in between which gets ignored;
% avoids having to build a new node list?)
%    \begin{macrocode}
\newenvironment*{autotabbing@cell}{%
  \edef\autotabbing@prev{\the\autotabbing@current}%
  \setbox0=\hbox\bgroup%
    \autotabbing@cell@start%
    \ignorespaces%
}{%
    \hss%
  \egroup%
  \setbox0=\hbox attr0=2 attr1=\autotabbing@prev attr2=\autotabbing@current{\unhbox0}%
  \box0%
}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\autotabbing@cell@next}
% Skip to the next cell. Ensure increasing tabs, without an argument we just
% advance the counter. We do this while in the current cell, so that it knows
% at which tab it ends.
%    \begin{macrocode}
\newcommand*{\autotabbing@cell@next}[1][0]{%
  \ifnum #1 > \the\autotabbing@current%
    \global\autotabbing@current #1\relax%
  \else%
    \global\advance\autotabbing@current 1\relax%
  \fi%
  \end{autotabbing@cell}%
  \begin{autotabbing@cell}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{\autotabbing@row}
% A row starts at tab 0 and ends at tab 1000.
%    \begin{macrocode}
\newenvironment*{autotabbing@row}{%
  \global\autotabbing@current 0\relax%
  \hbox attr0=1\bgroup%
  \begin{autotabbing@cell}%
}{%
  \global\autotabbing@current 1000\relax%
  \end{autotabbing@cell}%
  \egroup%
}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\autotabbing@row@next}
% Closes the current row and immediately opens a new one.
% We can't control row spacing here because this is between boxes, landing
% before the rows.
%    \begin{macrocode}
\newcommand{\autotabbing@row@next}{%
  \end{autotabbing@row}%
  \begin{autotabbing@row}%
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\autotabbing@intertext}
% Interrupt the display. Must follow a |\\|, but doesn't check.
%    \begin{macrocode}
\newcommand{\autotabbing@intertext}[1]{%
  %\end{autotabbing@cell}%
  \end{autotabbing@row}%
  #1%\hbox to \hsize{\vbox{#1}}%
  \par\begin{autotabbing@row}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{autotabbing}
% Define tabular-like syntax, start collecting the cells,
% and use Lua to insert the final product.
% We unskip the final space here for comfort, but not from any other cells.
%    \begin{macrocode}
\catcode`&=\active
\newenvironment*{autotabbing}[1][]{%
  \autotabbingsetup{#1}%
  \let\\=\autotabbing@row@next%
  \let&=\autotabbing@cell@next%
  \catcode`\&=\active%
  \let\intertext=\autotabbing@intertext%
  \par\dimen255=\prevdepth%
  \setbox0=\vbox\bgroup%
    \prevdepth=\dimen255% correct baselineskip glue
    \begin{autotabbing@row}%
}{%
      \unskip%
    \end{autotabbing@row}%
  \egroup%
  % align the cells
  \directlua{autotabbing.adjust()}%
  \unvbox0%
  % no indent if not followed by a newline
  \noindent%
  \ignorespacesafterend%
}
\catcode`& 4
%</package>
%    \end{macrocode}
% \end{environment}
%
%
%    \begin{macrocode}
%<*lua>
local err, warn, info, log = luatexbase.provides_module({name = 'autotabbing'})
autotabbing = autotabbing or {}
%    \end{macrocode}
% Get the horizontal offsets of the tab stops.
% We measure the cells column-wise (keeping track using the |index| table,
% since we might not visit a cell in each row every step) by selecting those
% starting at the current stop (which had its offset calculated in a previous
% step), and moving the cell's end-stops.
% A cell may end at any stop with a larger index than its start.
% There may be gaps in the tab numbers, and their offsets don't have to be in
% the same order.
%    \begin{macrocode}
local function get_offsets(rows)
  local offsets = {[0] = 0}
  local index = {}
  for i = 1, #rows do index[i] = 1 end
  local current = 0
  repeat
    for i, row in ipairs(rows) do
      local cell = row.cells[index[i]]
      if cell and cell.from == current then
        local width = cell.box.width --node.dimensions(cell.box)
        local left = offsets[cell.from]
        if not left then
          err(string.format("invalid tabs: from=%d to=%d",
            cell.from, cell.to))
          offsets[cell.from] = 0
          left = 0
        end
        local right = left + width
        if right >= (offsets[cell.to] or 0) then
          offsets[cell.to] = right
        end
        index[i] = index[i] + 1
      end
    end
    current = 1000
    for i, row in ipairs(rows) do
      local cell = row.cells[index[i]]
      if cell and cell.from < current then
        current = cell.from
      end
    end
  until current == 1000
  return offsets
end
%    \end{macrocode}
% Replace the box in its list with a new one of a fixed size, returns the new box.
%    \begin{macrocode}
local function repack_hbox(box, ...)
  local prev = box.prev
  local next = box.next
  box = node.hpack(box.head, ...)
  if prev then
    box.prev = prev
    prev.next = box
  end
  if next then
    next.prev = box
    box.next = next
  end
  return box
end
%    \end{macrocode}
% Alter each cell's widths so they fit between their respective stops.
%    \begin{macrocode}
local function adjust_widths(head, rows)
  local offsets = get_offsets(rows)
  for _, row in ipairs(rows) do
    for _, cell in ipairs(row.cells) do
      local width = offsets[cell.to] - offsets[cell.from]
      cell.box = repack_hbox(cell.box, width, 'exactly')
      if not cell.box.prev then row.box.head = cell.box end
    end
    local width = offsets[1000] - offsets[0]
    row.box = repack_hbox(row.box) --, width, 'exactly')
    if not row.box.prev then head = row.box end
  end
  return head
end




function autotabbing.adjust()
local b = node.copy(tex.box[0])
print('VBOX', b)
  local rows = {}
  for row in node.traverse(b.head) do
    if node.has_attribute(row, 0, 1) then
      print('ROW', row)
      local rowA = {
        cells={},
        box=row
      }
      table.insert(rows, rowA)
      for cell in node.traverse(row.head) do
        if node.has_attribute(cell, 0, 2) then
          local from = node.has_attribute(cell, 1)
          local to = node.has_attribute(cell, 2)
          local cellA = {
            from=from,
            to=to,
            box=cell
          }
          table.insert(rowA.cells, cellA)
          print('CELL', cell, from, '-', to)
        end
      end
    end
  end
  b.head = adjust_widths(b.head, rows)
  tex.box[0] = b
end






%</lua>
%    \end{macrocode}
%
%
% \Finale
\endinput
